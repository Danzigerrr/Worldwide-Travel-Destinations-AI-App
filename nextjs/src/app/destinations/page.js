'use client';

import { useState, useEffect, useRef, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import axios from 'axios';
import qs from 'qs';

import DestinationsList from '../components/DestinationsList';

// Generic multi-select dropdown component
function MultiSelect({ label, options = [], selected = [], onChange }) {
    const [open, setOpen] = useState(false);
    const containerRef = useRef();

    useEffect(() => {
        const handleClickOutside = (e) => {
            if (containerRef.current && !containerRef.current.contains(e.target)) {
                setOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const toggleOption = (value) => {
        const newSelected = selected.includes(value)
            ? selected.filter(v => v !== value)
            : [...selected, value];
        onChange(newSelected);
    };

    return (
        <div className="relative" ref={containerRef}>
            <button
                type="button"
                onClick={() => setOpen(o => !o)}
                className="btn w-full p-2 border rounded text-left flex justify-between items-center bg-white hover:bg-gray-50 transition-colors"
            >
                <span>{label}</span>
                <span>{open ? '▴' : '▾'}</span>
            </button>
            {open && (
                <div className="absolute mt-1 w-full bg-grey border rounded shadow max-h-60 overflow-auto z-10">
                    {options.length > 0 ? (
                        options.map(opt => (
                            <label key={opt} className="flex items-center p-2 hover:bg-gray-50 cursor-pointer">
                                <input
                                    type="checkbox"
                                    checked={selected.includes(opt)}
                                    onChange={() => toggleOption(opt)}
                                    className="mr-2"
                                />
                                <span>{opt}</span>
                            </label>
                        ))
                    ) : (
                        <p className="p-2 text-gray-500">No options available</p>
                    )}
                </div>
            )}
        </div>
    );
}

export default function DestinationsListPage() {
    const router = useRouter();
    const [destinations, setDestinations] = useState([]);
    const [loadingDestinations, setLoadingDestinations] = useState(true); // Renamed for clarity
    const [errorDestinations, setErrorDestinations] = useState(null); // Renamed for clarity

    // State to hold ALL possible filter values from the backend
    const [possibleFilterOptions, setPossibleFilterOptions] = useState({
        region: [], country: [], budget_level: [], culture: [], adventure: [],
        nature: [], beaches: [], nightlife: [], cuisine: [], wellness: [],
        urban: [], seclusion: [], trip_type: [],
    });
    const [loadingFilterOptions, setLoadingFilterOptions] = useState(true); // New state for filter options loading
    const [errorFilterOptions, setErrorFilterOptions] = useState(null); // New state for filter options error

    const initialFilters = {
        region: [], country: [], budget_level: [], culture: [], adventure: [],
        nature: [], beaches: [], nightlife: [], cuisine: [], wellness: [],
        urban: [], seclusion: [], trip_type: [],
    };

    const [filters, setFilters] = useState(initialFilters);
    // New state for dynamic filters generated by LLM
    const [generatedDynamicFilters, setGeneratedDynamicFilters] = useState([]);
    const [generatingDynamicFilters, setGeneratingDynamicFilters] = useState(false);
    const [dynamicFilterError, setDynamicFilterError] = useState(null);


    const resetFilters = () => {
        setFilters(initialFilters);
        setGeneratedDynamicFilters([]); // Clear dynamic filters on reset
    };

    const handleFilterChange = (key) => (values) => {
        setFilters(prev => ({ ...prev, [key]: values }));
    };

    const fetchDestinationsAndOptions = async (params = {}) => {
        console.log("Fetching destinations with params:", params);
        const queryString = qs.stringify(params, { arrayFormat: 'comma' });

        const token = localStorage.getItem('token') || '';
        const header = token ? { Authorization: `Bearer ${token}` } : {};
        console.log("params:", params);
        const res = await axios.get(`http://localhost:8000/destinations?${queryString}`, {
            headers: header,
        });
        return res.data;
    };

    const fetchDynamicFiltersFromBackend = async () => {
        setGeneratingDynamicFilters(true);
        setDynamicFilterError(null);
        try {
            // Send current filters as context for LLM if desired
            const currentFilterParams = {};
            Object.entries(filters).forEach(([k, arr]) => {
                if (Array.isArray(arr) && arr.length > 0) {
                    currentFilterParams[`${k}__in`] = arr;
                }
            });
            const queryString = qs.stringify(currentFilterParams, { arrayFormat: 'comma' });

            const token = localStorage.getItem('token') || '';
            const header = token ? { Authorization: `Bearer ${token}` } : {};

            const res = await axios.get(`http://localhost:8000/dynamic_filters?${queryString}`, {
                headers: header,
            });

            console.log("Generated filters: ", res.data);
            setGeneratedDynamicFilters(res.data);
        } catch (err) {
            console.error("Error fetching dynamic filters:", err);
            setDynamicFilterError(err);
        } finally {
            setGeneratingDynamicFilters(false);
        }
    };

    const applyFilters = async () => {
        setLoadingDestinations(true); // Set loading for destinations only
        setErrorDestinations(null);
        try {
            const params = {};

            Object.entries(filters).forEach(([k, arr]) => {
                if (Array.isArray(arr) && arr.length > 0) {
                    params[`${k}__in`] = arr;
                }
            });

            const responseData = await fetchDestinationsAndOptions(params);

            setDestinations(responseData.destinations);
            // No longer updating possibleFilterOptions here, it's done once on mount
            // setPossibleFilterOptions(responseData.possible_values);

        } catch (err) {
            console.error("Error applying filters:", err);
            setErrorDestinations(err);
        } finally {
            setLoadingDestinations(false);
        }
    };

    // New handler for dynamic filter selection
    const handleDynamicFilterSelection = (feature, value) => {
        setFilters(prevFilters => ({
            ...prevFilters,
            [feature]: [value]
        }));
        setGeneratedDynamicFilters([]); // Clear dynamic filters
    };

    // Effect to fetch initial filter options ONCE when the component mounts
    useEffect(() => {
        const fetchInitialFilterOptions = async () => {
            setLoadingFilterOptions(true);
            setErrorFilterOptions(null);
            try {
                const responseData = await fetchDestinationsAndOptions({}); // Fetch with no initial filters to get all possible values
                setPossibleFilterOptions(responseData.possible_values);
            } catch (err) {
                console.error("Error fetching initial filter options:", err);
                setErrorFilterOptions(err);
            } finally {
                setLoadingFilterOptions(false);
            }
        };

        fetchInitialFilterOptions();
    }, []); // Empty dependency array means this runs once on mount

    // Effect to fetch destinations whenever filters change
    useEffect(() => {
        // Only fetch destinations if filter options have been loaded.
        // This prevents an initial double-fetch of destinations.
        if (!loadingFilterOptions) {
            applyFilters();
        }
    }, [filters, loadingFilterOptions]); // Dependency array: run this effect whenever 'filters' or 'loadingFilterOptions' changes

    const humanize = s => s.replace(/_/g,' ').replace(/\b\w/g, c => c.toUpperCase()); // Improved humanize for 'budget_level' etc.

    // Memoize sorted options for performance and consistent order
    // Ensure these only sort after possibleFilterOptions are loaded
    const sortedRegionOptions = useMemo(() => possibleFilterOptions.region.sort(), [possibleFilterOptions.region]);
    const sortedCountryOptions = useMemo(() => possibleFilterOptions.country.sort(), [possibleFilterOptions.country]);
    const sortedBudgetOptions = useMemo(() => possibleFilterOptions.budget_level.sort(), [possibleFilterOptions.budget_level]);

    const sortedCultureOptions = useMemo(() => possibleFilterOptions.culture.sort((a, b) => a - b), [possibleFilterOptions.culture]);
    const sortedAdventureOptions = useMemo(() => possibleFilterOptions.adventure.sort((a, b) => a - b), [possibleFilterOptions.adventure]);
    const sortedNatureOptions = useMemo(() => possibleFilterOptions.nature.sort((a, b) => a - b), [possibleFilterOptions.nature]);
    const sortedBeachesOptions = useMemo(() => possibleFilterOptions.beaches.sort((a, b) => a - b), [possibleFilterOptions.beaches]);
    const sortedNightlifeOptions = useMemo(() => possibleFilterOptions.nightlife.sort((a, b) => a - b), [possibleFilterOptions.nightlife]);
    const sortedCuisineOptions = useMemo(() => possibleFilterOptions.cuisine.sort((a, b) => a - b), [possibleFilterOptions.cuisine]);
    const sortedWellnessOptions = useMemo(() => possibleFilterOptions.wellness.sort((a, b) => a - b), [possibleFilterOptions.wellness]);
    const sortedUrbanOptions = useMemo(() => possibleFilterOptions.urban.sort((a, b) => a - b), [possibleFilterOptions.urban]);
    const sortedSeclusionOptions = useMemo(() => possibleFilterOptions.seclusion.sort((a, b) => a - b), [possibleFilterOptions.seclusion]);

    const sortedTripTypeOptions = useMemo(() => possibleFilterOptions.trip_type.sort(), [possibleFilterOptions.trip_type]);


    // Render loading state for the entire page if initial filter options are still loading
    if (loadingFilterOptions) {
        return <p>Loading page...</p>; // Or a more elaborate full-page loader
    }

    // Render error for initial filter options if any
    if (errorFilterOptions) {
        return <p className="text-red-600">Error loading initial filters: {errorFilterOptions.message}</p>;
    }


    return (
        <div className="p-6">
            <h1 className="text-2xl mb-4">Destinations searcher</h1>

            {/* Existing Filters Section */}
            <div className="mb-6 p-4 bg-gray-50 rounded space-y-4">
                <h2 className="text-lg font-semibold">Filters</h2>
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                    <MultiSelect label="Region" options={sortedRegionOptions} selected={filters.region} onChange={handleFilterChange('region')} />
                    <MultiSelect label="Country" options={sortedCountryOptions} selected={filters.country} onChange={handleFilterChange('country')} />
                    <MultiSelect label="Budget" options={sortedBudgetOptions} selected={filters.budget_level} onChange={handleFilterChange('budget_level')} />
                    <MultiSelect label="Culture" options={sortedCultureOptions} selected={filters.culture} onChange={handleFilterChange('culture')} />
                    <MultiSelect label="Adventure" options={sortedAdventureOptions} selected={filters.adventure} onChange={handleFilterChange('adventure')} />
                    <MultiSelect label="Nature" options={sortedNatureOptions} selected={filters.nature} onChange={handleFilterChange('nature')} />
                    <MultiSelect label="Beaches" options={sortedBeachesOptions} selected={filters.beaches} onChange={handleFilterChange('beaches')} />
                    <MultiSelect label="Nightlife" options={sortedNightlifeOptions} selected={filters.nightlife} onChange={handleFilterChange('nightlife')} />
                    <MultiSelect label="Cuisine" options={sortedCuisineOptions} selected={filters.cuisine} onChange={handleFilterChange('cuisine')} />
                    <MultiSelect label="Wellness" options={sortedWellnessOptions} selected={filters.wellness} onChange={handleFilterChange('wellness')} />
                    <MultiSelect label="Urban" options={sortedUrbanOptions} selected={filters.urban} onChange={handleFilterChange('urban')} />
                    <MultiSelect label="Seclusion" options={sortedSeclusionOptions} selected={filters.seclusion} onChange={handleFilterChange('seclusion')} />
                    <MultiSelect label="Trip Type" options={sortedTripTypeOptions.map(humanize)} selected={filters.trip_type} onChange={handleFilterChange('trip_type')} />
                </div>

                <div className="flex space-x-2 mt-4">
                    <button
                        onClick={applyFilters}
                        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
                    >
                        Apply Filters
                    </button>
                    <button
                        onClick={resetFilters}
                        className="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400 transition-colors"
                    >
                        Reset Filters
                    </button>
                </div>
            </div>

            {/* --- Dynamic Filters Section --- */}
            <div className="mb-6 p-4 bg-yellow-50 rounded space-y-4">
                <h2 className="text-lg font-semibold">Dynamic Filter Suggestions</h2>
                <button
                    onClick={fetchDynamicFiltersFromBackend}
                    className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors"
                    disabled={generatingDynamicFilters}
                >
                    {generatingDynamicFilters ? 'Generating...' : 'Get Dynamic Filter Suggestions'}
                </button>

                {dynamicFilterError && (
                    <p className="text-red-600 mt-2">Error generating suggestions: {dynamicFilterError.message}</p>
                )}

                {generatedDynamicFilters.length > 0 && (
                    <div className="space-y-4 mt-4">
                        {generatedDynamicFilters.map((df, index) => (
                            <div key={index} className="border p-3 rounded bg-grey shadow-sm">
                                <p className="font-medium text-black-700 mb-2">{df.question}</p>
                                <div className="flex flex-wrap gap-3">
                                    {Object.entries(df.value_meanings).map(([value, meaning]) => (
                                        <button
                                            key={value}
                                            onClick={() => handleDynamicFilterSelection(df.feature, value)}
                                            className={`px-3 py-1 rounded text-sm transition-colors
                                                ${filters[df.feature].includes(value)
                                                ? 'bg-blue-500 text-white'
                                                : 'bg-gray-200 text-gray-800 hover:bg-blue-200'
                                            }`}
                                        >
                                            {meaning}
                                        </button>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>

            {/* Destinations List */}
            <hr className="my-6" /> {/* Optional separator */}
            <h2 className="text-xl mb-4">Available Destinations ({destinations.length})</h2>
            {loadingDestinations && <p>Loading destinations…</p>}
            {errorDestinations && <p className="text-red-600">Error loading destinations: {errorDestinations.message}</p>}
            {!loadingDestinations && !errorDestinations && (
                <DestinationsList destinations={destinations} tripTypes={possibleFilterOptions.trip_type} humanize={humanize} router={router} />
            )}
        </div>
    );
}